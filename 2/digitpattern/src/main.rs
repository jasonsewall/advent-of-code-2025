use log::info;
use simple_logger::SimpleLogger;
use std::env;
use std::error::Error;
use std::fs;
/*
repeated digits in ranges

1. # of digits.
a. Odd # of digits only admits single-digit patterns
b. N even digits should be checked for patterns of length [1,N/2]
2. Valid patterns to look for
a. Low/upper range dictates different lengths to look at (see above)
b. Also dictate which patterns should be looked at
3. Patterns will "nest", so we shouldn't check for longer patterns that contain shorter ones. I.e. 111111 is both a single digit "1" pattern, a 2-digit "11" pattern, and a 3-digit "111" pattern.

To generate:

1. Identify different digit lengths in range
2. For each such length:
   a. For each valid pattern-generator length
      i. Generate each pattern from the pattern-generator

*/

// Generate patterns with generation-length base that fit in n digits. Skip ones that would have been generated by shorter lengths.
// N = 1

fn parse_int(input: &[u8]) -> Option<(usize, u64)> {
    let mut last = 0;
    for c in input {
        if *c < b'0' || *c > b'9' {
            break;
        }
        last += 1;
    }
    if last > 0 {
        let the_str = std::str::from_utf8(&input[..last]).expect("Not utf-8");
        let num = the_str.parse::<u64>().expect("Not a number");
        return Some((last, num));
    }
    None
}

fn parse_single_range(input: &[u8]) -> Option<(usize, (u64, u64))> {
    let (num1_idx, start) = parse_int(&input)?;
    if input[num1_idx] != b'-' {
        panic!("Expected '-', got {}", input[num1_idx]);
    }

    let (num2_idx, end) = parse_int(&input[num1_idx + 1..])?;

    return Some((num2_idx + num1_idx + 1, (start, end)));
}

// Parse comma-delimited list of ranges
fn parse_ranges(input: &[u8]) -> Vec<(u64, u64)> {
    let mut last = 0;
    let mut res = Vec::<(u64, u64)>::new();
    loop {
        match parse_single_range(&input[last..]) {
            Some((new_last, range)) => {
                last += new_last;
                res.push(range);
            }
            None => {
                panic!("didn't parse!");
            }
        };
        if last == input.len() {
            break;
        }
        if input[last] == b'\n' {
            break;
        }
        if input[last] != b',' {
            panic!("Expected comma, got {}", input[last]);
        }
        last += 1;
    }
    res
}

fn make_pattern_num(prefix: u64, seq_len: u32, ntimes: u32) -> u64 {
    assert!(seq_len > 0);
    assert!(ntimes > 0);
    let mut res = prefix;
    for t in 1..ntimes {
        res += prefix * 10_u64.pow(seq_len * t);
    }
    res
}

fn check_seq(num: u64, ndigits: u32, seq_len: u32) -> bool {
    if ndigits % seq_len != 0 {
        return false;
    }
    let ntimes = ndigits / seq_len;

    let prefix = num / 10_u64.pow(ndigits - seq_len);
    num == make_pattern_num(prefix, seq_len, ntimes)
}

fn count_digits(num: u64) -> u32 {
    if num == 0 {
        return 0;
    }
    let log10: u32 = num.ilog10();
    if 10_u64.pow(log10) < num {
        return log10 + 1;
    }
    log10
}

fn check_int(num: u64) -> bool {
    let ndigits: u32 = count_digits(num);
    for sl in 1..(ndigits / 2) + 1 {
        if check_seq(num, ndigits, sl) {
            return true;
        }
    }
    false
}

fn check_int_pair(num: u64) -> bool {
    let ndigits: u32 = count_digits(num);
    if ndigits % 2 == 1 {
        return false;
    }
    return check_seq(num, ndigits, ndigits / 2);
}

fn add_in_range(range: (u64, u64)) -> u64 {
    let mut res = 0;
    for n in range.0..(range.1 + 1) {
        if check_int(n) {
            info!("{} is invalid", n);
            res += n;
        }
    }
    res
}

fn add_invalid_in_ranges(input: &[u8]) -> u64 {
    let ranges = parse_ranges(&input);

    let mut sum = 0;
    for r in ranges {
        let v = add_in_range(r);
        sum += v;
        info!("[{}-{}] -> {} ({})", r.0, r.1, r.1 - r.0, v);
    }
    sum
}

fn main() -> Result<(), Box<dyn Error>> {
    SimpleLogger::new().init().unwrap();
    let mut args = env::args().skip(1).peekable();
    let file = match args.next() {
        Some(file) => file,
        None => {
            return Err(From::from("Need a file argument!"));
        }
    };
    let input = fs::read(file)?;
    println!("sum is: {}", add_invalid_in_ranges(&input));
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_make_pattern() {
        assert_eq!(1, make_pattern_num(1, 1, 1));
        assert_eq!(11, make_pattern_num(1, 1, 2));
        assert_eq!(1212, make_pattern_num(12, 2, 2));
    }

    #[test]
    fn test_check_seq() {
        assert!(check_seq(1212, 4, 2));
        assert!(check_seq(55555, 5, 1));
        assert!(check_seq(1234512345, 10, 5));
    }

    #[test]
    fn test_check_seq_neg() {
        assert!(!check_seq(1211, 4, 2));
        assert!(!check_seq(55255, 5, 1));
    }

    #[test]
    fn test_check_int() {
        assert!(check_int(1111));
        assert!(check_int(1234512345));
        assert!(!check_int(543));
    }
    #[test]
    fn test_check_example() {
        let input = "11-22,95-115,998-1012,1188511880-1188511890,222220-222224,1698522-1698528,446443-446449,38593856-38593862,565653-565659,824824821-824824827,2121212118-2121212124".as_bytes();
        assert_eq!(add_invalid_in_ranges(input), 1227775554);
    }
}
